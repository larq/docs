<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script>
(function() {
  function addWidgetsRenderer() {
    var mimeElement = document.querySelector('script[type="application/vnd.jupyter.widget-view+json"]');
    var scriptElement = document.createElement('script');
    var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js';
    var widgetState;

    // Fallback for older version:
    try {
      widgetState = mimeElement && JSON.parse(mimeElement.innerHTML);

      if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) {
        widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js';
      }
    } catch(e) {}

    scriptElement.src = widgetRendererSrc;
    document.body.appendChild(scriptElement);
  }

  document.addEventListener('DOMContentLoaded', addWidgetsRenderer);
}());
</script>

<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
# End to End Guide: Converting and Benchmarking a Model
<a href="https://mybinder.org/v2/gh/larq/docs/master?filepath=docs%2Fcompute-engine%2Fend_to_end.ipynb"><button class="notebook-badge">Run on Binder</button></a> <a href="https://github.com/larq/docs/blob/master/docs/larq/compute-engine/end_to_end.ipynb"><button class="notebook-badge">View on GitHub</button></a>

These steps will walk you through deploying a BNN with LCE. The guide starts by downloading, converting and benchmarking a model from [Larq Zoo](https://docs.larq.dev/zoo/), and will then discuss the process for a custom model.

## 1. Picking a model from Larq Zoo
This example uses the [QuickNet model](https://docs.larq.dev/zoo/api/sota/#quicknet) from the `sota` submodule of `larq-zoo`.
First, install the Larq Ecosystem pip packages:

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
!pip install larq larq-zoo larq-compute-engine
```

</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
Then, create a python script that will download QuickNet and print the model summary:
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
import larq as lq
import larq_compute_engine as lce
import larq_zoo as lqz


# Load the QuickNet architecture and download the weights for ImageNet
model = lqz.sota.QuickNet(weights="imagenet")
lq.models.summary(model)
model.save("quicknet.h5")
```

</div>

<div class="output_wrapper" markdown="1">
<div class="output" markdown="1">


<div class="output_area" markdown="1">
<div class="output_subarea output_stream output_stdout output_text">
<pre>
<code>+quicknet stats----------------------------------------------------------------------------------------------------+
| Layer                   Input prec.                 Outputs  # 1-bit  # 32-bit   Memory  1-bit MACs  32-bit MACs |
|                               (bit)                              x 1       x 1     (kB)                          |
+------------------------------------------------------------------------------------------------------------------+
| input_1                           -  ((None, 224, 224, 3),)        0         0        0           ?            ? |
| conv2d                            -       (-1, 112, 112, 8)        0       216     0.84           0      2709504 |
| depthwise_conv2d                  -        (-1, 56, 56, 64)        0       576     2.25           0      1806336 |
| batch_normalization               -        (-1, 56, 56, 64)        0       128     0.50           0            0 |
| quant_conv2d                      1        (-1, 56, 56, 64)    36864         0     4.50   115605504            0 |
| batch_normalization_1             -        (-1, 56, 56, 64)        0       128     0.50           0            0 |
| add                               -        (-1, 56, 56, 64)        0         0        0           ?            ? |
| quant_conv2d_1                    1        (-1, 56, 56, 64)    36864         0     4.50   115605504            0 |
| batch_normalization_2             -        (-1, 56, 56, 64)        0       128     0.50           0            0 |
| add_1                             -        (-1, 56, 56, 64)        0         0        0           ?            ? |
| max_pooling2d                     -        (-1, 28, 28, 64)        0         0        0           0            0 |
| quant_conv2d_2                    1        (-1, 28, 28, 64)    36864         0     4.50    28901376            0 |
| batch_normalization_3             -        (-1, 28, 28, 64)        0       128     0.50           0            0 |
| batch_normalization_4             -        (-1, 28, 28, 64)        0       128     0.50           0            0 |
| add_2                             -        (-1, 28, 28, 64)        0         0        0           ?            ? |
| concatenate                       -       (-1, 28, 28, 128)        0         0        0           ?            ? |
| quant_conv2d_3                    1       (-1, 28, 28, 128)   147456         0    18.00   115605504            0 |
| batch_normalization_5             -       (-1, 28, 28, 128)        0       256     1.00           0            0 |
| add_3                             -       (-1, 28, 28, 128)        0         0        0           ?            ? |
| quant_conv2d_4                    1       (-1, 28, 28, 128)   147456         0    18.00   115605504            0 |
| batch_normalization_6             -       (-1, 28, 28, 128)        0       256     1.00           0            0 |
| add_4                             -       (-1, 28, 28, 128)        0         0        0           ?            ? |
| max_pooling2d_1                   -       (-1, 14, 14, 128)        0         0        0           0            0 |
| quant_conv2d_5                    1       (-1, 14, 14, 128)   147456         0    18.00    28901376            0 |
| batch_normalization_7             -       (-1, 14, 14, 128)        0       256     1.00           0            0 |
| batch_normalization_8             -       (-1, 14, 14, 128)        0       256     1.00           0            0 |
| add_5                             -       (-1, 14, 14, 128)        0         0        0           ?            ? |
| concatenate_1                     -       (-1, 14, 14, 256)        0         0        0           ?            ? |
| quant_conv2d_6                    1       (-1, 14, 14, 256)   589824         0    72.00   115605504            0 |
| batch_normalization_9             -       (-1, 14, 14, 256)        0       512     2.00           0            0 |
| add_6                             -       (-1, 14, 14, 256)        0         0        0           ?            ? |
| quant_conv2d_7                    1       (-1, 14, 14, 256)   589824         0    72.00   115605504            0 |
| batch_normalization_10            -       (-1, 14, 14, 256)        0       512     2.00           0            0 |
| add_7                             -       (-1, 14, 14, 256)        0         0        0           ?            ? |
| quant_conv2d_8                    1       (-1, 14, 14, 256)   589824         0    72.00   115605504            0 |
| batch_normalization_11            -       (-1, 14, 14, 256)        0       512     2.00           0            0 |
| add_8                             -       (-1, 14, 14, 256)        0         0        0           ?            ? |
| max_pooling2d_2                   -         (-1, 7, 7, 256)        0         0        0           0            0 |
| quant_conv2d_9                    1         (-1, 7, 7, 256)   589824         0    72.00    28901376            0 |
| batch_normalization_12            -         (-1, 7, 7, 256)        0       512     2.00           0            0 |
| batch_normalization_13            -         (-1, 7, 7, 256)        0       512     2.00           0            0 |
| add_9                             -         (-1, 7, 7, 256)        0         0        0           ?            ? |
| concatenate_2                     -         (-1, 7, 7, 512)        0         0        0           ?            ? |
| quant_conv2d_10                   1         (-1, 7, 7, 512)  2359296         0   288.00   115605504            0 |
| batch_normalization_14            -         (-1, 7, 7, 512)        0      1024     4.00           0            0 |
| add_10                            -         (-1, 7, 7, 512)        0         0        0           ?            ? |
| quant_conv2d_11                   1         (-1, 7, 7, 512)  2359296         0   288.00   115605504            0 |
| batch_normalization_15            -         (-1, 7, 7, 512)        0      1024     4.00           0            0 |
| add_11                            -         (-1, 7, 7, 512)        0         0        0           ?            ? |
| quant_conv2d_12                   1         (-1, 7, 7, 512)  2359296         0   288.00   115605504            0 |
| batch_normalization_16            -         (-1, 7, 7, 512)        0      1024     4.00           0            0 |
| add_12                            -         (-1, 7, 7, 512)        0         0        0           ?            ? |
| activation                        -         (-1, 7, 7, 512)        0         0        0           ?            ? |
| average_pooling2d                 -         (-1, 1, 1, 512)        0         0        0           0            0 |
| flatten                           -               (-1, 512)        0         0        0           0            0 |
| dense                             -              (-1, 1000)        0    513000  2003.91           0       512000 |
| activation_1                      -              (-1, 1000)        0         0        0           ?            ? |
+------------------------------------------------------------------------------------------------------------------+
| Total                                                        9990144    521088  3255.00  1242759168      5027840 |
+------------------------------------------------------------------------------------------------------------------+
+quicknet summary-----------------------------+
| Total params                      10.5 M    |
| Trainable params                  10.5 M    |
| Non-trainable params              7.3 k     |
| Model size                        3.18 MiB  |
| Model size (8-bit FP weights)     1.69 MiB  |
| Float-32 Equivalent               40.10 MiB |
| Compression Ratio of Memory       0.08      |
| Number of MACs                    1.25 B    |
| Ratio of MACs that are binarized  0.9960    |
+---------------------------------------------+
</code>
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
As you can see, the model size is 3.18 MiB, but the float-32 model size is 40.10 MiB. Indeed, if you look at the `quicknet.h5` file you just saved, you'll see that it is around 42 MiB in size. This is because the model is currently unoptimized and the weights are still stored as floats rather than binary values, so executing this model on any device wouldn't be very fast at all. 
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
## 2. Converting the model
Larq Compute Engine is built on top of TensorFlow Lite, and therefore uses the [TensorFlow Lite FlatBuffer format](https://google.github.io/flatbuffers/) to convert and serialize Larq models for inference. We provide our own [LCE Model Converter](https://docs.larq.dev/compute-engine/api/converter/) to convert models from Keras to flatbuffers, containing additional optimization passes that increase the execution speed of Larq models on the supported target platforms. 

Using this converter is very simple, and can be done by adding the following code to the python script above:
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
# Convert our Keras model to a TFLite flatbuffer file
with open("quicknet.tflite", "wb") as flatbuffer_file:
    flatbuffer_bytes = lce.convert_keras_model(model)
    flatbuffer_file.write(flatbuffer_bytes)
```

</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
This will produce the converted `quicknet.tflite` file with compressed weights and optimized operations, which is only just over 3 MiB in size!
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
## 3. Benchmarking
This part of the guide assumes that you'll want to benchmark on an Arm-64 based board such as a Raspberry Pi. For more detailed instructions on benchmarking, see the [Benchmarking guide](https://docs.larq.dev/compute-engine/benchmark).

On Arm64, benchmarking is as simple as downloading the pre-built benchmarking binary from the [latest release](https://github.com/larq/compute-engine/releases/latest) to the target device and running it with the converted model:

!!! warning
        The following code should be executed on the target platform, e.g. a Raspberry Pi. The exclamation marks should be          removed, but are necessary here to make this valid notebook syntax.
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
!wget <TODO-URL> -o benchmark_model
!chmod +x benchmark_model
!./benchmark_model --graph=quicknet.tflite --num_runs=50 --num_threads=1
```

</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
The number of interest here is `Inference (avg)`, which in this case is 33.1 ms (33071.8 microseconds) on a [Raspberry Pi 4B](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/README.md).

To see the other available benchmarking options, add `--help` to the command above.
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
## 4. Create your own Larq model
Instead of using one of our models, you probably want to benchmark a custom model that you trained yourself. For more information on creating and training a BNN with Larq, see our [Larq User Guides](https://docs.larq.dev/). For best practices on optimizing Larq models for LCE, also see our [Model Optimization Guide](https://docs.larq.dev/compute-engine/model_optimization_guide).

The code below defines a simple BNN model that takes a 32x32 input image and classifies it into one of 10 classes.
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
import tensorflow as tf

# Define a custom model
model = tf.keras.models.Sequential(
    [
        tf.keras.layers.Input((32, 32, 3)),
        # First layer (float)
        tf.keras.layers.Conv2D(32, kernel_size=(5, 5), padding="same", strides=3),
        tf.keras.layers.BatchNormalization(),
        # Note: we do NOT add a ReLU here, because the subsequent activation quantizer would destroy all information!
        # Second layer (binary)
        lq.layers.QuantConv2D(
            32,
            kernel_size=(3, 3),
            padding="same",
            strides=2,
            input_quantizer="ste_sign",
            kernel_quantizer="ste_sign",
            kernel_constraint="weight_clip",
            use_bias=False  # We don't need a bias, since the BatchNorm already has a learnable offset
        ),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Activation("relu"),
        # Third layer (binary)
        lq.layers.QuantConv2D(
            64,
            kernel_size=(3, 3),
            padding="same",
            strides=2,
            input_quantizer="ste_sign",
            kernel_quantizer="ste_sign",
            kernel_constraint="weight_clip",
            use_bias=False  # We don't need a bias, since the BatchNorm already has a learnable offset
        ),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Activation("relu"),
        # Pooling and final dense layer (float)
        tf.keras.layers.GlobalAveragePooling2D(),
        tf.keras.layers.Dense(10, activation="softmax"),
    ]
)
lq.models.summary(model)
model.save("custom_model.h5")

# Note: Realistically, you would of course want to train your model before converting it!

# Convert our Keras model to a TFLite flatbuffer file
with open("custom_model.tflite", "wb") as flatbuffer_file:
    flatbuffer_bytes = lce.convert_keras_model(model)
    flatbuffer_file.write(flatbuffer_bytes)


```

</div>

<div class="output_wrapper" markdown="1">
<div class="output" markdown="1">


<div class="output_area" markdown="1">
<div class="output_subarea output_stream output_stdout output_text">
<pre>
<code>+sequential_1 stats---------------------------------------------------------------------------------------------+
| Layer                       Input prec.           Outputs  # 1-bit  # 32-bit  Memory  1-bit MACs  32-bit MACs |
|                                   (bit)                        x 1       x 1    (kB)                          |
+---------------------------------------------------------------------------------------------------------------+
| conv2d_2                              -  (-1, 11, 11, 32)        0      2432    9.50           0       290400 |
| batch_normalization_20                -  (-1, 11, 11, 32)        0        64    0.25           0            0 |
| quant_conv2d_15                       1    (-1, 6, 6, 32)     9216         0    1.12      331776            0 |
| batch_normalization_21                -    (-1, 6, 6, 32)        0        64    0.25           0            0 |
| activation_4                          -    (-1, 6, 6, 32)        0         0       0           ?            ? |
| quant_conv2d_16                       1    (-1, 3, 3, 64)    18432         0    2.25      165888            0 |
| batch_normalization_22                -    (-1, 3, 3, 64)        0       128    0.50           0            0 |
| activation_5                          -    (-1, 3, 3, 64)        0         0       0           ?            ? |
| global_average_pooling2d_1            -          (-1, 64)        0         0       0           ?            ? |
| dense_2                               -          (-1, 10)        0       650    2.54           0          640 |
+---------------------------------------------------------------------------------------------------------------+
| Total                                                        27648      3338   16.41      497664       291040 |
+---------------------------------------------------------------------------------------------------------------+
+sequential_1 summary--------------------------+
| Total params                      31 k       |
| Trainable params                  30.7 k     |
| Non-trainable params              256        |
| Model size                        16.41 KiB  |
| Model size (8-bit FP weights)     6.63 KiB   |
| Float-32 Equivalent               121.04 KiB |
| Compression Ratio of Memory       0.14       |
| Number of MACs                    789 k      |
| Ratio of MACs that are binarized  0.6310     |
+----------------------------------------------+
</code>
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
Now that the model is converted, it is useful to visualize it in [netron](https://lutzroeder.github.io/netron/) to make sure the network looks as expected. For the model above, the first part of the flatbuffer looks like this:

![](../images/custom_model_netron_1.png)

There is an unexpected `Mul` operation between the two binary convolutions, fused with a `ReLU`. Since `BatchNormalization` and `ReLU` can be efficiently fused into the convolution operation, this indicates that something about our model configuration is suboptimal.

There are two culprits here, both explained in the [Model Optimization Guide](https://docs.larq.dev/compute-engine/model_optimization_guide):

1. The order of `BatchNormalization` and `ReLU` is incorrect. Not only does this prevent fusing these operators with the convolution, but since ReLU produces only positive values, the subsequent `LCEQuantize` operation will turn the entire output into ones, and the network cannot learn anything. This can be easily fixed by reversing the order of these two operations:
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
# Example code for a correct ordering of binary convolution, ReLU and BatchNorm.
lq.layers.QuantConv2D(
    32,
    kernel_size=(3, 3),
    padding="same",
    strides=2,
    input_quantizer="ste_sign",
    kernel_quantizer="ste_sign",
    kernel_constraint="weight_clip",
    use_bias=False   # We don't need a bias, since the BatchNorm already has a learnable offset
)
tf.keras.layers.Activation("relu")
tf.keras.layers.BatchNormalization()
```

</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
2. However, if you change the model definition above to incorporate these changes, the graph looks like this:

![](../images/custom_model_netron_2.png)

Which is even worse, because there are now two unfused operations (`ReLU` and `Mul`) instead of one (`Mul` with fused `ReLU`).

This is because while the binary convolutions use `padding="same"`, no padding value was specified and therefore the default value of 0 is used. Since binary weights can only take two values, -1 and 1, this 0 cannot also be represented in the existing input tensor, so an additional correction step is necessary and the `ReLU` cannot be fused. This can be resolved by using `pad_values=1` for the binary convolutions:
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered" markdown="1">
<div class="input">

```python
# Example code for a fusable configuration of a binary convolution with "same" padding, including ReLU and BatchNorm.
lq.layers.QuantConv2D(
    32,
    kernel_size=(3, 3),
    padding="same",
    pad_values=1,
    strides=2,
    input_quantizer="ste_sign",
    kernel_quantizer="ste_sign",
    kernel_constraint="weight_clip",
    use_bias=False   # We don't need a bias, since the BatchNorm already has a learnable offset
)
tf.keras.layers.Activation("relu")
tf.keras.layers.BatchNormalization()
```

</div>

</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">
After making these final changes to the model definition above, the model looks correct at last:

![](../images/custom_model_netron_final.png)

The `ReLu` and `BatchNormalization` operations have now successfully been fused into the convolution operation, meaning the inference engine just has to execute a single operation instead of three!
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered" markdown="1">
<div class="inner_cell" markdown="1">
<div class="text_cell_render border-box-sizing rendered_html" markdown="1">

</div>
</div>
</div>


